#!/bin/bash

#################################
#################################
############ Warning to allow sudo
echo -e "NOTE: This bash script will require sudo priviledges. Kindly key in your password if prompted.\n"

#################################
#################################
############ 0.1 Initialize

## Create temporary folder based on timestamp
startTime=$(date +'%Y%m%d%H%M%S%Z')
tmpDir="tmp${startTime}"
mkdir "$tmpDir"
cd "$tmpDir"

## Psudo code to trigger sudo authentication
sudo mkdir test

## Initialize a final report file to store all results
reportfile="scan_report_${startTime}"
touch "$reportfile"

###### Defining repetitive functions
## print on display and also the report
printfn() {
	echo -e $1
	echo -e $1 >> "$reportfile"
}

## print only on the report
printfn0() {
	echo -e $1 >> "$reportfile"
}

## print on display, report and also individual host summary
printfn2() {
	echo -e $1
	echo -e $1 >> "$reportfile"
	echo -e $1 >> "res-$2-summary"
}

## function to ask user for input to continue
continueCheck() {
	while true; do
		read -p  "Continue? (Y/N)" answer
		# Check the user's response
		if [ "$answer" = "Y" ]; then
			break
		elif [ "$answer" = "N" ]; then
			echo -e "Please try again."
			# Do nothing
		else
			echo "Invalid input."
		fi
	done
}

#################################
#################################
############ 0.0 Introductions

echo "#########################"
echo -e "#########################\n"
echo -e "Created by:\n"
echo " SSSSS    22222    22222 "
echo "S        22  22   22   22"
echo "S           22        22 "
echo " SSSSS    2222      2222  "
echo "     S   22        22     "
echo "SSSSS    222222   222222 "
echo -e "\n#########################"

echo -e "\n#### Introduction"
echo -e "\nThis script will map your current network and find different attack vectors. Based on the active hosts, open ports will be identified. Next, finding users with weak passwords and potential vulnerabilities based on service detection. Results will be saved in a report file."
echo -e "\nYou will first be prompted to provide a list of Username and Passwords. The list will be used to check for weak passwords in the network services.\n"
continueCheck


#################################
#################################
#################################
#################################
#################################
############ 2.1 Allow the user to specify a user list – (5 Points)

## Prompt the user
echo -e "\nKindly provide a list of \e[32mUSERNAMES\e[0m, and once you are done, enter +end"
output_file1="user_list.txt"

## Read and store user inputs
while true; do
    read -p "> " userInput
    ## Stop when user keys the string "+end"
    if [[ "$userInput" == "+end" ]]; then
        break
    fi
    ## store each entry into the user_list file
    echo "$userInput" >> "$output_file1"
done

## Inform the user
echo -e "Username inputs are stored in $output_file1"


#################################
#################################
############ 2.3 Allow the user to create a password list – (5 Points)

## Prompt the user for input
echo -e "\nKindly provide a list of \e[32mPASSWORDS\e[0m, and once you are done, enter +end"
output_file2="password_list.txt"

while true; do
	read -p "> " userInput
	## Stop when user keys the string "+end"
	if [[ "$userInput" == "+end" ]]; then
		break
	fi
	## store each entry into the user_list file
	echo "$userInput" >> "$output_file2"
done

## inform the user
echo -e "Password inputs are stored in $output_file2"


#################################
#################################
############ 2.2 Allow the user to specify a password list – (5 Points)

## Create a function to prompt user for path to a template password file
## Function used for better code segmentation
getPasswordListPath() {

	## A variable to check if path is valid, default set to FALSE i.e. not valid
	valid_path=false

	### Prompt user to provide path
	while [ "$valid_path" = false ]; do
		echo -e "\nPlease specify a password list by providing the file path:"
		read userInput
		path_userpasswordlist="$userInput"

		## Check if the file exists and is a regular file
		if [ -f "$path_userpasswordlist" ]; then
			valid_path=true  # Set the flag to exit the loop
			echo -e "You have provided \e[32m$path_userpasswordlist\e[0m"
			
			## Count the number of lines in the file and display to the user for confirmation
			line_count=$(wc -l < "$path_userpasswordlist")
			echo "The file has $line_count items"
			
			## Request for confirmation from the user
			while true; do
				read -p "Do you confirm this file? (Y/N): " confirmation
				case "$confirmation" in
					[Yy]* )
						## if user confirmed, exit the loop
						valid_path=true  # Set the flag to exit the confirmation loop and accept the input
						break ;;
					[Nn]* )
						## if user does not confirm, also exit the confirmation loop to re-prompt for new input
						break ;;
					* )
						echo "Please enter Y or N." ;;
				esac
			done
		else
			echo "File path is invalid or doesn't exist. Please provide a valid file path."
			# The loop will continue until a valid file path is provided
		fi
	done

	## Copy the Password List into the working directory
	cp $path_userpasswordlist passwordfile_template

	## Add the template password list into the user provided list for a combined list to be used in brute forcing portion later
	cat passwordfile_template >> $output_file2
	
}

while true; do
	# Ask the user if they want to provide a templated list
	echo -e ""
	read -p  "Do you want to also use a templated password list? (Y/N): " answer

	# Check the user's response
	if [ "$answer" = "Y" ]; then
		getPasswordListPath
		break
		
	elif [ "$answer" = "N" ]; then
		echo "Ok, we will proceed with the list you provided earlier."
		path_userpasswordlist="NULL"
		break
		
	else
		echo "Invalid input."
	fi
done

## Consolidate brute force inputs as a summary to be displayed
printfn0 " ## Brute force summary\n"
printfn0 "User-defined username list: $output_file1"
printfn0 "User-defined password list: $output_file2"
printfn0 "Template password list path: $path_userpasswordlist"

#################################
#################################
########### Inform user

sleep 1
echo -e "\nThank you for your inputs, the script will run. This will take a couple of minutes or longer depending on the network."
sleep 2

# Record the start time
start_time=$(date +%s)
echo -e "\nScan started at: $(date)"

#################################
#################################
############ 1.1 Automatically identify the LAN network range – (10 Points)

printfn "\e[32m\n##### Device scan\e[0m"

#### Get the default network interface
default_interface=$(ip route | awk '/default/ {print $5}')

#### Extract network range using the default interface
network_cidr=$(ip -o -f inet addr show $default_interface | awk -F' ' '{print $4}')
network_range=$(netmask -r $network_cidr)

printfn "\nDefault Interface: $default_interface"
printfn "LAN Network Range: $network_range"

#################################
#################################
############ 1.2 Automatically scan the current LAN – (10 Points)

#### do nmap scan to find active hosts and store in a file
sudo nmap -sn 192.168.136.136/24 -oX res0 > /dev/null

#### extract only the ip addresses and store in a new file
cat res0 | grep "address addr" | grep ipv4 | awk -F '"' '{print $2}' > res0ipall

#### Remove the host ip from the list
host_ip=$(hostname -I | cut -d' ' -f1)
cat res0ipall | grep -vE "$host_ip" > res0ip

#### print the output into the terminal
hostNum=$(cat res0ip | wc -l)
printfn "\nFound $hostNum active hosts:"
cat res0ip
cat res0ip >> "$reportfile"

#################################
#################################
############ 1.3 Enumerate each live host – (10 Points)

printfn "\e[32m\n##### Port scan\e[0m"

#### for each ip inside the file saved in 1.2
while IFS= read -r ipaddr; do

	## Set up the individual host summary report
	echo -e "\n\e[93m###########################\e[0m" >> "res-${ipaddr}-summary"
	echo -e "\n\e[93m#### Report for $ipaddr\e[0m" >> "res-${ipaddr}-summary"

	#### do an nmap scan to check for open ports and save the result in a new file
    echo -e "\nScanning for $ipaddr ..."
	sudo nmap $ipaddr -sV -oX "res-${ipaddr}" > /dev/null
	
	#### extract only the port numbers into a file list
	cat "res-${ipaddr}" | grep port | grep open | awk -F '"' '{print $4}' > "res-${ipaddr}-pList"
	portNum=$(cat "res-${ipaddr}-pList" | wc -l)
	
	#### extract only the service name into a file list
	cat "res-${ipaddr}" | grep "service name=" | awk -F 'service name="' '{print $2}' | awk -F '"' '{print $1}'  > "res-${ipaddr}-pList-servicename"
	
	#### print results
	echo "Found $portNum open ports on $ipaddr"
	printfn2 "\e[32m\n$ipaddr > $portNum open ports\e[0m" "$ipaddr"
	awk '{printf "%s|", $0}' "res-${ipaddr}-pList" | sed 's/|$//'
	printfn2 " "
	#~ cat "res-${ipaddr}-pList" >> "$reportfile"
	awk '{printf "%s|", $0}' "res-${ipaddr}-pList" | sed 's/|$//' >> "$reportfile"
	awk '{printf "%s|", $0}' "res-${ipaddr}-pList" | sed 's/|$//' >> "res-${ipaddr}-summary"
	
done < res0ip

#################################
#################################
############ 1.4 Find potential vulnerabilities for each device – (10 Points)
echo -e "\n######################################################"
echo -e "##### Finding Potential Vulnerabilities for each device"

#### for each ip inside the file saved in 1.2
while IFS= read -r ipaddr; do
	printfn2 "\e[32m\n#### Potential Vulnerabilities for $ipaddr\e[0m\n" "$ipaddr"
	
	#### Serach for potential vulnerabilities in each port service
	line_number=0
	while IFS= read -r portid; do
		((line_number++))
		
		## Print the scan parameters
		service_name=$(sed -n "${line_number}p" "res-${ipaddr}-pList-servicename")
		printfn2 "[port: $portid | service: $service_name]" "$ipaddr"
		
		## Scan for vulnerabilities using nmap default vulnerability scripts
		sudo nmap -Pn --script vuln "${ipaddr}" -p "${portid}" -oX "res-${ipaddr}-p${portid}-vuln" > /dev/null
		
		# print the results
		vulnName=$(cat "res-${ipaddr}-p${portid}-vuln" | grep title | awk -F '>' '{print $2}' | awk -F '<' '{print $1}')
		
		if [[ -n "${vulnName}" && ! -z "${vulnName}" ]]; then
			counter=1
			cat "res-${ipaddr}-p${portid}-vuln" | grep title | awk -F '>' '{print $2}' | awk -F '<' '{print $1}' > tmp-vuln-names
			while IFS= read -r line; do
					printfn2 "\e[31m.. $counter- $line\e[0m" "$ipaddr"
					((counter++))
				done < "tmp-vuln-names"
		fi
	done < "res-${ipaddr}-pList"
	echo "done ~"
done < res0ip

#### If using the online database
#git clone https://github.com/scipag/vulscan scipag_vulscan 
#sudo ln -s `pwd`/scipag_vulscan /usr/share/nmap/scripts/vulscan
#nmap -sV --script=vulscan/vulscan.nse 192.168.136.137 -p 21,22

#################################
#################################
############ 2.5 If more than one login service is available, choose the first service – (10 Points)
    
## List of services that hydra supports for logging in
HydraServices="dam6500 asterisk cisco cisco-enable cobaltstrike cvs firebird ftp[s] http[s]-{head|get|post} http[s]-{get|post}-form http-proxy http-proxy-urlenum icq imap[s] irc ldap2[s] ldap3[-{cram|digest}md5][s] memcached mongodb mssql mysql nntp oracle-listener oracle-sid pcanywhere pcnfs pop3[s] postgres radmin2 rdp redis rexec rlogin rpcap rsh rtsp s7-300 sip smb smtp[s] smtp-enum snmp socks5 ssh sshkey svn teamspeak telnet[s] vmauthd vnc xmpp"

## Define the files
usernamefile="user_list.txt"
passwordfile="password_list.txt"

# Loop to brute force the first login service of each IP address
while IFS= read -r ip_address; do
    
	printfn "######################################\n"
    printfn "#### Checking passwords on $ip_address\n"
	
	### Check which is the first service that can be brute force by hydra (if available)
	line_number=0
	firstProtocol=TRUE
	selected_protocol="NULL"
	
	while IFS= read -r service; do
		((line_number++))
		
		## Check if the service is part of the hydra list
		if [[ $HydraServices == *"$service"* ]]; then
			port_number=$(sed -n "${line_number}p" "res-${ip_address}-pList")
			printfn "\e[32m$service > $ip_address:$port_number\e[0m"
			echo -e "$service > $ip_address:$port_number" >> "res-${ip_address}-pList-servicename-hydra"
			
			## Store the values if it is the first service supported by hydra
			if [[ $firstProtocol == TRUE ]]; then
				selected_port=$port_number
				selected_protocol=$service
				firstProtocol=FALSE
			fi
			
		fi
	done < "res-${ip_address}-pList-servicename"
    
    ## Run hydra for the first service stored earlier
    if [[ "$selected_protocol" != "NULL" ]]; then

		printfn2 "\e[32m\n#### Hyrda Brtue force on $ip_address port $selected_port via $selected_protocol\e[0m" "$ip_address"
		printfn2 "User List: $usernamefile" "$ip_address"
		printfn2 "Password List: $passwordfile\n" "$ip_address"
		
		## Run hydra command
		hydra -L $usernamefile -P $passwordfile $ip_address $selected_protocol -s $selected_port -o "res-${ip_address}-hydra-output"
		
		## Store the results
		cat "res-${ip_address}-hydra-output" | grep "host:" >> "$reportfile"
		cat "res-${ip_address}-hydra-output" | grep "host:" >> "res-${ip_address}-summary"

		echo -e ""
	fi
      
    echo -e "\nEnd ~" >> "res-${ip_address}-summary"
	echo -e "\n###########################" >> "res-${ip_address}-summary" 
      
done < res0ip

#################################
#################################
############ 3.1 Display general statistics (time of the scan, number of found devices, etc.) – (5 Points)

# Record the stop time
stop_time=$(date +%s)
echo "Script stopped at: $(date)"

# Calculate the difference in timing
time_diff=$((stop_time - start_time))

# Calculate minutes and seconds
minutes=$((time_diff / 60))
seconds=$((time_diff % 60))

printfn "###############################################################"
printfn "\e[32mTotal time of the scan: $minutes minutes $seconds seconds ($difference_seconds seconds).\e[0m"
printfn "###############################################################"

#################################
#################################
############ 3.2 Save all the results into a report – (5 Points)

scanDir="scanres-${startTime}"
mkdir "../${scanDir}"

## Remove the runtime files and temporary folder, keeping only report files
cp "$reportfile" "../${scanDir}/scan_report_all"
cp "res0ip" "../${scanDir}/res0ip"

while IFS= read -r ipaddr; do
	cp "res-${ipaddr}-summary" "../${scanDir}/scan_report_${ipaddr}"
done < res0ip

## Remove all the temporary files
cd ..
sudo rm -r "$tmpDir"

#################################
#################################
############ 3.3 Allow the user to enter an IP address; display the relevant findings – (5 Points)

# Displaying the numbered list of IP addresses
while true; do
	echo -e "\nPlease select which ip address to view results (e.g. 2): "
	awk '{print NR" - "$0}' "./${scanDir}/res0ip"

	# Prompt user for selection
	echo -e ""
	read -p $'\e[93mSelect:\e[0m ' selected_number

	# Validate user input and store the selected IP address
	selected_ip=$(awk -v num="$selected_number" 'NR==num {print $0}' "./${scanDir}/res0ip")

	if [ -z "$selected_ip" ]; then
		echo "Invalid selection."
	else
		#### display results using the individual host report
		cat "${scanDir}/scan_report_${selected_ip}"
		echo -e " "
		continueCheck
	fi
done
